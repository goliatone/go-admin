{"version":3,"file":"error-helpers.js","sources":["../../src/toast/error-helpers.ts"],"sourcesContent":["/**\n * Error message extraction helpers\n * Matches the repository's actual backend error formats\n */\n\n// ============================================================================\n// Structured Error Types\n// ============================================================================\n\n/**\n * Structured error result from API responses.\n * Used for typed error handling (e.g., translation blockers, validation).\n */\nexport interface StructuredError {\n  /** Domain error code (e.g., 'TRANSLATION_MISSING', 'VALIDATION_FAILED') */\n  textCode: string | null;\n  /** Human-readable error message */\n  message: string;\n  /** Error metadata (varies by error type) */\n  metadata: Record<string, unknown> | null;\n  /** Field-level validation errors */\n  fields: Record<string, string> | null;\n  /** Original validation_errors array if present */\n  validationErrors: ValidationError[] | null;\n}\n\n/**\n * Field validation error entry\n */\nexport interface ValidationError {\n  field: string;\n  message: string;\n}\n\n/**\n * Translation blocker metadata extracted from TRANSLATION_MISSING errors\n */\nexport interface TranslationBlockerInfo {\n  /** Locales that are missing translations */\n  missingLocales: string[];\n  /** Required fields missing per locale (optional) */\n  missingFieldsByLocale: Record<string, string[]> | null;\n  /** The workflow transition that was blocked (e.g., 'publish') */\n  transition: string | null;\n  /** Entity type (e.g., 'pages', 'posts') */\n  entityType: string | null;\n  /** The locale that was requested */\n  requestedLocale: string | null;\n  /** The environment context (e.g., 'production', 'staging') */\n  environment: string | null;\n}\n\n/**\n * Action response envelope types\n */\nexport interface ActionSuccessResponse {\n  status: 'ok';\n  data?: Record<string, unknown>;\n}\n\nexport interface ActionErrorResponse {\n  error: {\n    text_code?: string;\n    message?: string;\n    metadata?: Record<string, unknown>;\n    validation_errors?: Array<{ field?: string; message?: string }>;\n  };\n}\n\nexport type ActionResponse = ActionSuccessResponse | ActionErrorResponse;\n\n// ============================================================================\n// Structured Error Extraction\n// ============================================================================\n\n/**\n * Extract structured error from fetch Response.\n * Use this when you need typed error handling (text_code branching, metadata access).\n * For simple message display, use extractErrorMessage instead.\n */\nexport async function extractStructuredError(response: Response): Promise<StructuredError> {\n  const contentType = response.headers.get('content-type') || '';\n  const isJson =\n    contentType.includes('application/json') ||\n    contentType.includes('application/problem+json');\n\n  const bodyText = await response.clone().text().catch(() => '');\n\n  // Default result\n  const result: StructuredError = {\n    textCode: null,\n    message: `Request failed (${response.status})`,\n    metadata: null,\n    fields: null,\n    validationErrors: null,\n  };\n\n  if (!bodyText) {\n    return result;\n  }\n\n  // Try JSON parsing\n  if (isJson || bodyText.trim().startsWith('{')) {\n    try {\n      const data = JSON.parse(bodyText) as Record<string, unknown>;\n\n      // Handle structured error envelope: { error: { text_code, message, metadata, validation_errors } }\n      if (data.error && typeof data.error === 'object') {\n        const errObj = data.error as Record<string, unknown>;\n\n        // Extract text_code\n        if (typeof errObj.text_code === 'string') {\n          result.textCode = errObj.text_code;\n        }\n\n        // Extract message\n        if (typeof errObj.message === 'string' && errObj.message.trim()) {\n          result.message = errObj.message.trim();\n        }\n\n        // Extract metadata\n        if (errObj.metadata && typeof errObj.metadata === 'object') {\n          result.metadata = errObj.metadata as Record<string, unknown>;\n        }\n\n        // Extract validation_errors\n        if (Array.isArray(errObj.validation_errors)) {\n          const validationErrors: ValidationError[] = [];\n          const fields: Record<string, string> = {};\n\n          for (const entry of errObj.validation_errors) {\n            if (!entry || typeof entry !== 'object') continue;\n            const field = (entry as Record<string, unknown>).field;\n            const msg = (entry as Record<string, unknown>).message;\n            if (typeof field === 'string' && typeof msg === 'string') {\n              validationErrors.push({ field, message: msg });\n              fields[field] = msg;\n            }\n          }\n\n          if (validationErrors.length > 0) {\n            result.validationErrors = validationErrors;\n            result.fields = fields;\n          }\n        }\n\n        // Also check metadata.fields for field-level errors\n        if (result.metadata?.fields && typeof result.metadata.fields === 'object' && !Array.isArray(result.metadata.fields)) {\n          const metaFields = result.metadata.fields as Record<string, unknown>;\n          if (!result.fields) {\n            result.fields = {};\n          }\n          for (const [field, msg] of Object.entries(metaFields)) {\n            if (typeof msg === 'string') {\n              result.fields[field] = msg;\n            }\n          }\n        }\n\n        return result;\n      }\n\n      // Handle simple string error: { error: \"message\" }\n      if (typeof data.error === 'string' && data.error.trim()) {\n        result.message = data.error.trim();\n        return result;\n      }\n\n      // Handle Problem+JSON format: { detail, title }\n      if (typeof data.detail === 'string' && data.detail.trim()) {\n        result.message = data.detail.trim();\n        return result;\n      }\n      if (typeof data.title === 'string' && data.title.trim()) {\n        result.message = data.title.trim();\n        return result;\n      }\n\n      // Handle generic message field\n      if (typeof data.message === 'string' && data.message.trim()) {\n        result.message = data.message.trim();\n        return result;\n      }\n    } catch {\n      // Not valid JSON, continue to text parsing\n    }\n  }\n\n  // Handle text-based errors\n  if (bodyText.includes('go-users:')) {\n    const match = bodyText.match(/go-users:\\s*([^|]+)/);\n    if (match) {\n      result.message = match[1].trim();\n      return result;\n    }\n  }\n\n  // Pipe-separated errors\n  const pipeMatch = bodyText.match(/\\|\\s*([^|]+)$/);\n  if (pipeMatch) {\n    result.message = pipeMatch[1].trim();\n    return result;\n  }\n\n  // Short text responses\n  if (bodyText.trim().length > 0 && bodyText.length < 200) {\n    result.message = bodyText.trim();\n    return result;\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Translation Blocker Extraction\n// ============================================================================\n\n/**\n * Extract translation blocker information from a structured error.\n * Returns null if the error is not a TRANSLATION_MISSING error.\n */\nexport function extractTranslationBlocker(error: StructuredError): TranslationBlockerInfo | null {\n  if (error.textCode !== 'TRANSLATION_MISSING') {\n    return null;\n  }\n\n  const metadata = error.metadata || {};\n\n  // Extract missing_locales\n  let missingLocales: string[] = [];\n  if (Array.isArray(metadata.missing_locales)) {\n    missingLocales = metadata.missing_locales.filter((v): v is string => typeof v === 'string');\n  }\n\n  // Extract missing_fields_by_locale\n  let missingFieldsByLocale: Record<string, string[]> | null = null;\n  if (metadata.missing_fields_by_locale && typeof metadata.missing_fields_by_locale === 'object') {\n    missingFieldsByLocale = {};\n    const raw = metadata.missing_fields_by_locale as Record<string, unknown>;\n    for (const [locale, fields] of Object.entries(raw)) {\n      if (Array.isArray(fields)) {\n        missingFieldsByLocale[locale] = fields.filter((v): v is string => typeof v === 'string');\n      }\n    }\n    // If no valid entries, set to null\n    if (Object.keys(missingFieldsByLocale).length === 0) {\n      missingFieldsByLocale = null;\n    }\n  }\n\n  // Extract other metadata fields\n  const transition = typeof metadata.transition === 'string' ? metadata.transition : null;\n  const entityType = typeof metadata.entity_type === 'string'\n    ? metadata.entity_type\n    : (typeof metadata.policy_entity === 'string' ? metadata.policy_entity : null);\n  const requestedLocale = typeof metadata.requested_locale === 'string' ? metadata.requested_locale : null;\n  const environment = typeof metadata.environment === 'string' ? metadata.environment : null;\n\n  return {\n    missingLocales,\n    missingFieldsByLocale,\n    transition,\n    entityType,\n    requestedLocale,\n    environment,\n  };\n}\n\n/**\n * Check if a structured error is a translation blocker\n */\nexport function isTranslationBlocker(error: StructuredError): boolean {\n  return error.textCode === 'TRANSLATION_MISSING';\n}\n\n// ============================================================================\n// Action Response Parsing\n// ============================================================================\n\n/**\n * Parse action response from panel action endpoint.\n * Returns typed result for deterministic control flow.\n */\nexport function parseActionResponse(data: unknown): {\n  success: boolean;\n  data?: Record<string, unknown>;\n  error?: StructuredError;\n} {\n  if (!data || typeof data !== 'object') {\n    return {\n      success: false,\n      error: {\n        textCode: null,\n        message: 'Invalid response format',\n        metadata: null,\n        fields: null,\n        validationErrors: null,\n      },\n    };\n  }\n\n  const obj = data as Record<string, unknown>;\n\n  // Check for success response: { status: \"ok\", data?: {...} }\n  if (obj.status === 'ok') {\n    const result: { success: boolean; data?: Record<string, unknown> } = { success: true };\n    if (obj.data && typeof obj.data === 'object') {\n      result.data = obj.data as Record<string, unknown>;\n    }\n    return result;\n  }\n\n  // Check for error response: { error: {...} }\n  if (obj.error && typeof obj.error === 'object') {\n    const errObj = obj.error as Record<string, unknown>;\n    const error: StructuredError = {\n      textCode: typeof errObj.text_code === 'string' ? errObj.text_code : null,\n      message: typeof errObj.message === 'string' ? errObj.message : 'Unknown error',\n      metadata: errObj.metadata && typeof errObj.metadata === 'object'\n        ? errObj.metadata as Record<string, unknown>\n        : null,\n      fields: null,\n      validationErrors: null,\n    };\n\n    // Extract validation errors\n    if (Array.isArray(errObj.validation_errors)) {\n      const validationErrors: ValidationError[] = [];\n      const fields: Record<string, string> = {};\n\n      for (const entry of errObj.validation_errors) {\n        if (!entry || typeof entry !== 'object') continue;\n        const field = (entry as Record<string, unknown>).field;\n        const msg = (entry as Record<string, unknown>).message;\n        if (typeof field === 'string' && typeof msg === 'string') {\n          validationErrors.push({ field, message: msg });\n          fields[field] = msg;\n        }\n      }\n\n      if (validationErrors.length > 0) {\n        error.validationErrors = validationErrors;\n        error.fields = fields;\n      }\n    }\n\n    return { success: false, error };\n  }\n\n  // Unknown format - try to extract a message\n  let message = 'Unknown response format';\n  if (typeof obj.message === 'string') {\n    message = obj.message;\n  } else if (typeof obj.error === 'string') {\n    message = obj.error;\n  }\n\n  return {\n    success: false,\n    error: {\n      textCode: null,\n      message,\n      metadata: null,\n      fields: null,\n      validationErrors: null,\n    },\n  };\n}\n\n/**\n * Execute a panel action and parse the response with typed handling.\n * Handles both success and error envelopes.\n */\nexport async function executeActionRequest(\n  endpoint: string,\n  payload: Record<string, unknown>,\n  options?: RequestInit\n): Promise<{\n  success: boolean;\n  data?: Record<string, unknown>;\n  error?: StructuredError;\n}> {\n  try {\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      ...options,\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      const error = await extractStructuredError(response);\n      return { success: false, error };\n    }\n\n    const data = await response.json();\n    return parseActionResponse(data);\n  } catch (err) {\n    return {\n      success: false,\n      error: {\n        textCode: null,\n        message: err instanceof Error ? err.message : 'Network error',\n        metadata: null,\n        fields: null,\n        validationErrors: null,\n      },\n    };\n  }\n}\n\n// ============================================================================\n// Legacy Message Extraction (backward compatible)\n// ============================================================================\n\n/**\n * Extract user-friendly error message from fetch Response\n * Handles multiple backend formats used in this repo:\n * 1. /admin/api/* format: {status, error} (quickstart/error_fiber.go)\n * 2. /admin/crud/* format: Problem+JSON {detail, title} (go-crud)\n * 3. go-users errors: Text with \"go-users:\" prefix\n */\nexport async function extractErrorMessage(response: Response): Promise<string> {\n  const contentType = response.headers.get('content-type') || '';\n  const isJson =\n    contentType.includes('application/json') ||\n    contentType.includes('application/problem+json');\n\n  const bodyText = await response.clone().text().catch(() => '');\n\n  if (bodyText) {\n    // Try JSON payloads first (including Problem Details)\n    if (isJson || bodyText.trim().startsWith('{')) {\n      try {\n        const data = JSON.parse(bodyText) as Record<string, unknown>;\n\n        // Priority 1: /admin/api/* format (quickstart/error_fiber.go:18)\n        if (typeof data.error === 'string' && data.error.trim()) return data.error.trim();\n        if (data.error && typeof data.error === 'object') {\n          const errObj = data.error as Record<string, unknown>;\n          const message =\n            typeof errObj.message === 'string' ? errObj.message.trim() : '';\n          const fieldMessages: string[] = [];\n\n          if (Array.isArray(errObj.validation_errors)) {\n            for (const entry of errObj.validation_errors) {\n              if (!entry || typeof entry !== 'object') continue;\n              const field = (entry as Record<string, unknown>).field;\n              const msg = (entry as Record<string, unknown>).message;\n              if (typeof field === 'string' && typeof msg === 'string') {\n                fieldMessages.push(`${field}: ${msg}`);\n              }\n            }\n          }\n\n          const metadata = errObj.metadata;\n          if (metadata && typeof metadata === 'object') {\n            const fields = (metadata as Record<string, unknown>).fields;\n            if (fields && typeof fields === 'object' && !Array.isArray(fields)) {\n              for (const [field, msg] of Object.entries(fields)) {\n                if (typeof msg === 'string') {\n                  fieldMessages.push(`${field}: ${msg}`);\n                }\n              }\n            }\n          }\n\n          if (fieldMessages.length > 0) {\n            const prefix =\n              message && message.toLowerCase() !== 'validation failed'\n                ? `${message}: `\n                : 'Validation failed: ';\n            return `${prefix}${fieldMessages.join('; ')}`;\n          }\n          if (message) return message;\n        }\n\n        // Priority 2: Problem+JSON (go-crud)\n        if (typeof data.detail === 'string' && data.detail.trim()) return data.detail.trim();\n        if (typeof data.title === 'string' && data.title.trim()) return data.title.trim();\n\n        // Priority 3: Generic message field\n        if (typeof data.message === 'string' && data.message.trim()) return data.message.trim();\n      } catch {\n        // Not JSON (or parse failed) - fall through to text handling\n      }\n    }\n\n    // Extract go-users errors: \"... | go-users: lifecycle transition not allowed\"\n    if (bodyText.includes('go-users:')) {\n      const match = bodyText.match(/go-users:\\s*([^|]+)/);\n      if (match) return match[1].trim();\n    }\n\n    // Extract pipe-separated errors (common pattern)\n    const pipeMatch = bodyText.match(/\\|\\s*([^|]+)$/);\n    if (pipeMatch) return pipeMatch[1].trim();\n\n    // If text is short enough, return it directly\n    if (bodyText.trim().length > 0 && bodyText.length < 200) return bodyText.trim();\n  }\n\n  // Fallback to status code\n  return `Request failed (${response.status})`;\n}\n\n/**\n * Extract error message from various error types\n */\nexport function getErrorMessage(error: unknown): string {\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  return 'An unexpected error occurred';\n}\n\n// ============================================================================\n// Translation Exchange Types (Phase 15 - prepared for backend integration)\n// ============================================================================\n\n/**\n * Exchange error codes for import/export operations.\n * These match the backend error codes from Phase 12 Task 12.3.\n */\nexport type ExchangeErrorCode =\n  | 'IMPORT_VALIDATION_FAILED'\n  | 'IMPORT_CONFLICT'\n  | 'IMPORT_LINKAGE_ERROR'\n  | 'IMPORT_UNSUPPORTED_FORMAT'\n  | 'IMPORT_STALE_SOURCE'\n  | 'EXPORT_FAILED'\n  | 'EXCHANGE_PERMISSION_DENIED';\n\n/**\n * Row-level result status for import validation/apply operations.\n */\nexport type ExchangeRowStatus =\n  | 'success'\n  | 'error'\n  | 'conflict'\n  | 'skipped';\n\n/**\n * Single row result from import validation or apply.\n * Matches contract from TDD: Phase 11 Task 11.6 (TranslationExchangeTypes).\n */\nexport interface ExchangeRowResult {\n  /** Row index in the import file (0-based) */\n  index: number;\n  /** Resource type (e.g., 'pages', 'posts') */\n  resource: string;\n  /** Entity ID in the source system */\n  entityId: string;\n  /** Translation group ID */\n  translationGroupId: string;\n  /** Target locale for this row */\n  targetLocale: string;\n  /** Field path being translated */\n  fieldPath: string;\n  /** Row processing status */\n  status: ExchangeRowStatus;\n  /** Error message if status is 'error' or 'conflict' */\n  error?: string;\n  /** Conflict details when status is 'conflict' */\n  conflict?: ExchangeConflictInfo;\n}\n\n/**\n * Conflict information for a single row.\n */\nexport interface ExchangeConflictInfo {\n  /** Type of conflict */\n  type: 'stale_source' | 'missing_linkage' | 'duplicate' | 'invalid_locale';\n  /** Expected source hash (for stale_source conflicts) */\n  expectedHash?: string;\n  /** Actual source hash in the file */\n  actualHash?: string;\n  /** Additional details */\n  details?: string;\n}\n\n/**\n * Summary statistics from import validation/apply.\n */\nexport interface ExchangeResultSummary {\n  /** Total rows processed */\n  processed: number;\n  /** Successfully processed rows */\n  succeeded: number;\n  /** Failed rows */\n  failed: number;\n  /** Rows with conflicts */\n  conflicts: number;\n  /** Rows skipped */\n  skipped: number;\n}\n\n/**\n * Full import validation/apply result.\n */\nexport interface ExchangeImportResult {\n  /** Summary statistics */\n  summary: ExchangeResultSummary;\n  /** Per-row results (may be truncated for large imports) */\n  results: ExchangeRowResult[];\n  /** Whether there are more results than returned */\n  truncated: boolean;\n  /** Total row count if truncated */\n  totalRows?: number;\n}\n\n/**\n * Export options for translation export workflow.\n */\nexport interface ExchangeExportOptions {\n  /** Resource types to export (e.g., ['pages', 'posts']) */\n  resources: string[];\n  /** Source locale */\n  sourceLocale: string;\n  /** Target locales to export for */\n  targetLocales: string[];\n  /** Field paths to include (empty = all translatable fields) */\n  fields?: string[];\n  /** Export format */\n  format: 'csv' | 'json' | 'xliff';\n  /** Include context columns (title, path, status, notes) */\n  includeContext?: boolean;\n}\n\n/**\n * Export result metadata.\n */\nexport interface ExchangeExportResult {\n  /** Number of rows exported */\n  rowCount: number;\n  /** Export format used */\n  format: 'csv' | 'json' | 'xliff';\n  /** Download URL or blob */\n  downloadUrl?: string;\n  /** Filename for download */\n  filename: string;\n}\n\n/**\n * Exchange-specific error info extracted from structured error.\n */\nexport interface ExchangeErrorInfo {\n  /** Exchange error code */\n  code: ExchangeErrorCode;\n  /** Human-readable message */\n  message: string;\n  /** Import result if validation failed */\n  importResult?: ExchangeImportResult;\n  /** Resource type context */\n  resource?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Exchange Error Extraction\n// ============================================================================\n\n/**\n * Check if an error is an exchange-related error.\n */\nexport function isExchangeError(error: StructuredError): boolean {\n  const exchangeCodes: string[] = [\n    'IMPORT_VALIDATION_FAILED',\n    'IMPORT_CONFLICT',\n    'IMPORT_LINKAGE_ERROR',\n    'IMPORT_UNSUPPORTED_FORMAT',\n    'IMPORT_STALE_SOURCE',\n    'EXPORT_FAILED',\n    'EXCHANGE_PERMISSION_DENIED',\n  ];\n  return error.textCode !== null && exchangeCodes.includes(error.textCode);\n}\n\n/**\n * Extract exchange error info from a structured error.\n * Returns null if not an exchange error.\n */\nexport function extractExchangeError(error: StructuredError): ExchangeErrorInfo | null {\n  if (!isExchangeError(error)) {\n    return null;\n  }\n\n  const metadata = error.metadata || {};\n  const result: ExchangeErrorInfo = {\n    code: error.textCode as ExchangeErrorCode,\n    message: error.message,\n    resource: typeof metadata.resource === 'string' ? metadata.resource : undefined,\n    metadata,\n  };\n\n  // Extract import result if present (for IMPORT_VALIDATION_FAILED)\n  if (metadata.import_result && typeof metadata.import_result === 'object') {\n    const raw = metadata.import_result as Record<string, unknown>;\n    result.importResult = parseImportResult(raw);\n  }\n\n  return result;\n}\n\n/**\n * Parse raw import result from API response.\n */\nexport function parseImportResult(data: Record<string, unknown>): ExchangeImportResult {\n  const result: ExchangeImportResult = {\n    summary: {\n      processed: 0,\n      succeeded: 0,\n      failed: 0,\n      conflicts: 0,\n      skipped: 0,\n    },\n    results: [],\n    truncated: false,\n  };\n\n  // Parse summary\n  if (data.summary && typeof data.summary === 'object') {\n    const summary = data.summary as Record<string, unknown>;\n    result.summary = {\n      processed: typeof summary.processed === 'number' ? summary.processed : 0,\n      succeeded: typeof summary.succeeded === 'number' ? summary.succeeded : 0,\n      failed: typeof summary.failed === 'number' ? summary.failed : 0,\n      conflicts: typeof summary.conflicts === 'number' ? summary.conflicts : 0,\n      skipped: typeof summary.skipped === 'number' ? summary.skipped : 0,\n    };\n  }\n\n  // Parse row results\n  if (Array.isArray(data.results)) {\n    result.results = data.results\n      .filter((row): row is Record<string, unknown> => row !== null && typeof row === 'object')\n      .map((row) => parseRowResult(row));\n  }\n\n  // Parse truncation info\n  if (typeof data.truncated === 'boolean') {\n    result.truncated = data.truncated;\n  }\n  if (typeof data.total_rows === 'number') {\n    result.totalRows = data.total_rows;\n  }\n\n  return result;\n}\n\n/**\n * Parse a single row result from API response.\n */\nfunction parseRowResult(row: Record<string, unknown>): ExchangeRowResult {\n  const result: ExchangeRowResult = {\n    index: typeof row.index === 'number' ? row.index : 0,\n    resource: typeof row.resource === 'string' ? row.resource : '',\n    entityId: typeof row.entity_id === 'string' ? row.entity_id : '',\n    translationGroupId: typeof row.translation_group_id === 'string' ? row.translation_group_id : '',\n    targetLocale: typeof row.target_locale === 'string' ? row.target_locale : '',\n    fieldPath: typeof row.field_path === 'string' ? row.field_path : '',\n    status: parseRowStatus(row.status),\n  };\n\n  if (typeof row.error === 'string') {\n    result.error = row.error;\n  }\n\n  if (row.conflict && typeof row.conflict === 'object') {\n    const conflict = row.conflict as Record<string, unknown>;\n    result.conflict = {\n      type: parseConflictType(conflict.type),\n      expectedHash: typeof conflict.expected_hash === 'string' ? conflict.expected_hash : undefined,\n      actualHash: typeof conflict.actual_hash === 'string' ? conflict.actual_hash : undefined,\n      details: typeof conflict.details === 'string' ? conflict.details : undefined,\n    };\n  }\n\n  return result;\n}\n\n/**\n * Parse row status from API response.\n */\nfunction parseRowStatus(value: unknown): ExchangeRowStatus {\n  if (value === 'success' || value === 'error' || value === 'conflict' || value === 'skipped') {\n    return value;\n  }\n  return 'error';\n}\n\n/**\n * Parse conflict type from API response.\n */\nfunction parseConflictType(value: unknown): ExchangeConflictInfo['type'] {\n  if (value === 'stale_source' || value === 'missing_linkage' || value === 'duplicate' || value === 'invalid_locale') {\n    return value;\n  }\n  return 'missing_linkage';\n}\n\n/**\n * Group exchange row results by status for UI rendering.\n */\nexport function groupRowResultsByStatus(results: ExchangeRowResult[]): {\n  success: ExchangeRowResult[];\n  error: ExchangeRowResult[];\n  conflict: ExchangeRowResult[];\n  skipped: ExchangeRowResult[];\n} {\n  return {\n    success: results.filter((r) => r.status === 'success'),\n    error: results.filter((r) => r.status === 'error'),\n    conflict: results.filter((r) => r.status === 'conflict'),\n    skipped: results.filter((r) => r.status === 'skipped'),\n  };\n}\n\n/**\n * Generate a downloadable report from exchange results.\n * Returns a Blob suitable for download.\n */\nexport function generateExchangeReport(\n  result: ExchangeImportResult,\n  format: 'json' | 'csv' = 'json'\n): Blob {\n  if (format === 'json') {\n    const content = JSON.stringify(result, null, 2);\n    return new Blob([content], { type: 'application/json' });\n  }\n\n  // CSV format\n  const headers = ['index', 'resource', 'entity_id', 'translation_group_id', 'target_locale', 'field_path', 'status', 'error', 'conflict_type'];\n  const rows = result.results.map((row) => [\n    String(row.index),\n    row.resource,\n    row.entityId,\n    row.translationGroupId,\n    row.targetLocale,\n    row.fieldPath,\n    row.status,\n    row.error || '',\n    row.conflict?.type || '',\n  ]);\n\n  const csvContent = [\n    headers.join(','),\n    ...rows.map((row) => row.map((cell) => `\"${cell.replace(/\"/g, '\"\"')}\"`).join(',')),\n  ].join('\\n');\n\n  return new Blob([csvContent], { type: 'text/csv' });\n}\n"],"names":["extractStructuredError","response","contentType","isJson","bodyText","result","data","errObj","validationErrors","fields","entry","field","msg","metaFields","match","pipeMatch","extractTranslationBlocker","error","metadata","missingLocales","v","missingFieldsByLocale","raw","locale","transition","entityType","requestedLocale","environment","isTranslationBlocker","parseActionResponse","obj","message","executeActionRequest","endpoint","payload","options","err","extractErrorMessage","fieldMessages","getErrorMessage","isExchangeError","exchangeCodes","extractExchangeError","parseImportResult","summary","row","parseRowResult","parseRowStatus","conflict","parseConflictType","value","groupRowResultsByStatus","results","r","generateExchangeReport","format","content","headers","rows","csvContent","cell"],"mappings":"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"}