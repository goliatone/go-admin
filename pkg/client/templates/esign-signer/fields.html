{% extends "login-layout.html" %}

{% block title %}Sign - {{ agreement.title|default:"Document" }}{% endblock %}

{% block head_extra %}
<style>
  .field-card {
    transition: all 0.2s ease;
  }
  .field-card.active {
    box-shadow: 0 0 0 2px var(--color-primary, #3b82f6);
  }
  .field-card.completed {
    border-color: #10b981;
    background-color: #f0fdf4;
  }
  .field-card.error {
    border-color: #ef4444;
    background-color: #fef2f2;
    box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
  }
  .field-card.error .field-error-badge {
    display: flex;
  }
  .field-error-badge {
    display: none;
  }
  .progress-bar {
    transition: width 0.3s ease-out;
  }
  .fade-in {
    animation: fadeIn 0.3s ease-out;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .signature-preview {
    min-height: 80px;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 39px,
      #e5e7eb 39px,
      #e5e7eb 40px
    );
  }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen flex flex-col bg-gray-50">
  <!-- Header Bar -->
  <header class="bg-white border-b border-gray-200 px-4 py-3 sm:px-6 sticky top-0 z-40" role="banner">
    <div class="max-w-4xl mx-auto">
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-3">
          {% if theme and theme.assets and theme.assets.icon %}
          <div class="w-8 h-8 bg-admin-dark rounded-lg flex items-center justify-center">
            <img src="{{ theme.assets.icon }}" alt="Logo" class="w-5 h-5 object-contain" />
          </div>
          {% else %}
          <div class="w-8 h-8 bg-admin-dark rounded-lg flex items-center justify-center">
            <i class="iconoir-signature text-white text-sm"></i>
          </div>
          {% endif %}
          <div class="hidden sm:block">
            <p class="text-sm font-medium text-gray-900 truncate max-w-[200px]">{{ agreement.title|default:"Document" }}</p>
            <p class="text-xs text-gray-500">Complete all required fields</p>
          </div>
        </div>

        <div class="flex items-center gap-3">
          <button
            type="button"
            onclick="openDocumentPreview()"
            class="btn btn-secondary text-sm py-2"
            aria-label="View full document"
          >
            <i class="iconoir-eye" aria-hidden="true"></i>
            <span class="hidden sm:inline ml-1">View Document</span>
          </button>
        </div>
      </div>

      <!-- Progress Bar -->
      <div class="space-y-1">
        <div class="flex items-center justify-between text-xs">
          <span class="text-gray-500">Progress</span>
          <span class="font-medium text-gray-700">
            <span id="completed-count">0</span> of <span id="total-count">{{ session.fields|length }}</span> fields
          </span>
        </div>
        <div class="h-2 bg-gray-200 rounded-full overflow-hidden" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
          <div id="progress-bar" class="progress-bar h-full bg-blue-600 rounded-full" style="width: 0%"></div>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="flex-1 px-4 py-6 sm:px-6" role="main">
    <div class="max-w-4xl mx-auto">
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- Fields List (Sidebar on large screens) -->
        <div class="lg:col-span-1 order-2 lg:order-1">
          <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden sticky top-28">
            <div class="px-4 py-3 border-b border-gray-100 bg-gray-50">
              <h2 class="text-sm font-semibold text-gray-900">Fields to Complete</h2>
            </div>
            <div class="divide-y divide-gray-100 max-h-[400px] overflow-y-auto" id="fields-list" role="list" aria-label="Signing fields">
              {% for field in session.fields %}
              <button
                type="button"
                class="field-nav-item w-full px-4 py-3 flex items-center gap-3 hover:bg-gray-50 transition-colors text-left"
                data-field-id="{{ field.id }}"
                data-field-index="{{ forloop.Counter0 }}"
                onclick="scrollToField('{{ field.id }}')"
                role="listitem"
                aria-current="{% if forloop.First %}true{% else %}false{% endif %}"
              >
                <div class="field-status-icon w-6 h-6 rounded-full flex items-center justify-center flex-shrink-0 {% if field.value_text or field.value_bool %}bg-green-100 text-green-600{% else %}bg-gray-100 text-gray-400{% endif %}">
                  {% if field.value_text or field.value_bool %}
                  <i class="iconoir-check text-sm" aria-hidden="true"></i>
                  {% else %}
                  <span class="text-xs font-medium">{{ forloop.Counter }}</span>
                  {% endif %}
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-gray-900 truncate">
                    {% if field.type == "signature" %}Signature{% elif field.type == "initials" %}Initials{% elif field.type == "name" %}Full Name{% elif field.type == "date_signed" %}Date{% elif field.type == "text" %}Text Field{% elif field.type == "checkbox" %}Checkbox{% else %}{{ field.type|title }}{% endif %}
                    {% if field.required %}<span class="text-red-500">*</span>{% endif %}
                  </p>
                  <p class="text-xs text-gray-500">Page {{ field.page }}</p>
                </div>
                <i class="iconoir-nav-arrow-right text-gray-400" aria-hidden="true"></i>
              </button>
              {% endfor %}
            </div>
          </div>
        </div>

        <!-- Active Field Area -->
        <div class="lg:col-span-2 order-1 lg:order-2 space-y-4" id="fields-container">
          {% for field in session.fields %}
          <div
            class="field-card bg-white rounded-xl shadow-sm border border-gray-200 p-6 {% if forloop.First %}active{% endif %}"
            id="field-{{ field.id }}"
            data-field-id="{{ field.id }}"
            data-field-type="{{ field.type }}"
            data-field-required="{{ field.required }}"
            role="region"
            aria-labelledby="field-label-{{ field.id }}"
          >
            <!-- Field Header -->
            <div class="flex items-start justify-between mb-4">
              <div>
                <h3 id="field-label-{{ field.id }}" class="text-lg font-semibold text-gray-900">
                  {% if field.type == "signature" %}
                  <i class="iconoir-signature text-purple-600 mr-2" aria-hidden="true"></i>Your Signature
                  {% elif field.type == "initials" %}
                  <i class="iconoir-text text-purple-600 mr-2" aria-hidden="true"></i>Your Initials
                  {% elif field.type == "name" %}
                  <i class="iconoir-user text-blue-600 mr-2" aria-hidden="true"></i>Full Name
                  {% elif field.type == "date_signed" %}
                  <i class="iconoir-calendar text-green-600 mr-2" aria-hidden="true"></i>Date Signed
                  {% elif field.type == "text" %}
                  <i class="iconoir-edit-pencil text-blue-600 mr-2" aria-hidden="true"></i>{{ field.label|default:"Text" }}
                  {% elif field.type == "checkbox" %}
                  <i class="iconoir-check-square text-green-600 mr-2" aria-hidden="true"></i>{{ field.label|default:"Confirmation" }}
                  {% endif %}
                  {% if field.required %}<span class="text-red-500 text-sm ml-1">Required</span>{% endif %}
                </h3>
                <p class="text-sm text-gray-500 mt-1">Page {{ field.page }}</p>
              </div>
              <div class="field-complete-badge hidden items-center gap-1 text-green-600 bg-green-50 px-2 py-1 rounded-full text-sm">
                <i class="iconoir-check" aria-hidden="true"></i>
                <span>Done</span>
              </div>
              <div class="field-error-badge items-center gap-1 text-red-600 bg-red-50 px-2 py-1 rounded-full text-sm cursor-pointer" onclick="retryField('{{ field.id }}')" title="Click to retry">
                <i class="iconoir-warning-circle" aria-hidden="true"></i>
                <span>Failed - Retry</span>
              </div>
            </div>

            <!-- Field Input Area -->
            <div class="field-input-area">
              {% if field.type == "signature" or field.type == "initials" %}
              <!-- Signature/Initials Field -->
              <div class="space-y-4">
                <div class="signature-container" data-field-id="{{ field.id }}">
                  <!-- Type selector tabs -->
                  <div class="flex border-b border-gray-200 mb-4" role="tablist" aria-label="Signature input method">
                    <button
                      type="button"
                      class="sig-tab-btn flex-1 py-2 text-sm font-medium text-center border-b-2 border-blue-600 text-blue-600"
                      data-tab="type"
                      role="tab"
                      aria-selected="true"
                      aria-controls="sig-type-{{ field.id }}"
                    >
                      Type
                    </button>
                    <button
                      type="button"
                      class="sig-tab-btn flex-1 py-2 text-sm font-medium text-center border-b-2 border-transparent text-gray-500 hover:text-gray-700"
                      data-tab="draw"
                      role="tab"
                      aria-selected="false"
                      aria-controls="sig-draw-{{ field.id }}"
                    >
                      Draw
                    </button>
                  </div>

                  <!-- Type signature panel -->
                  <div id="sig-type-{{ field.id }}" class="sig-panel" role="tabpanel" aria-labelledby="sig-tab-type-{{ field.id }}">
                    <input
                      type="text"
                      class="sig-type-input w-full text-2xl font-signature text-center py-4 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="{% if field.type == 'initials' %}Type your initials{% else %}Type your name{% endif %}"
                      data-field-id="{{ field.id }}"
                      value="{{ field.value_text }}"
                      aria-label="{% if field.type == 'initials' %}Type your initials{% else %}Type your signature{% endif %}"
                    />
                    <p class="text-xs text-gray-500 mt-2 text-center">Your typed {% if field.type == 'initials' %}initials{% else %}name{% endif %} will appear as your signature</p>
                  </div>

                  <!-- Draw signature panel -->
                  <div id="sig-draw-{{ field.id }}" class="sig-panel hidden" role="tabpanel" aria-labelledby="sig-tab-draw-{{ field.id }}">
                    <div class="relative border border-gray-200 rounded-lg overflow-hidden bg-white">
                      <canvas
                        class="sig-canvas w-full h-32 cursor-crosshair"
                        data-field-id="{{ field.id }}"
                        aria-label="Draw your signature"
                      ></canvas>
                      <button
                        type="button"
                        class="absolute bottom-2 right-2 text-xs text-gray-500 hover:text-gray-700 flex items-center gap-1"
                        onclick="clearSignatureCanvas('{{ field.id }}')"
                      >
                        <i class="iconoir-refresh" aria-hidden="true"></i> Clear
                      </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2 text-center">Draw your signature using mouse or touch</p>
                  </div>
                </div>

                <button
                  type="button"
                  class="btn btn-primary w-full justify-center field-apply-btn"
                  data-field-id="{{ field.id }}"
                  onclick="applySignature('{{ field.id }}')"
                >
                  Apply {% if field.type == 'initials' %}Initials{% else %}Signature{% endif %}
                </button>
              </div>

              {% elif field.type == "name" %}
              <!-- Name Field -->
              <div class="space-y-4">
                <input
                  type="text"
                  class="field-text-input w-full px-4 py-3 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Enter your full legal name"
                  data-field-id="{{ field.id }}"
                  value="{{ field.value_text }}"
                  oninput="handleFieldInput('{{ field.id }}', this.value)"
                  aria-label="Full name"
                />
                <button
                  type="button"
                  class="btn btn-primary w-full justify-center field-apply-btn"
                  data-field-id="{{ field.id }}"
                  onclick="saveTextField('{{ field.id }}')"
                >
                  Apply Name
                </button>
              </div>

              {% elif field.type == "date_signed" %}
              <!-- Date Field (Auto-filled, read-only) -->
              <div class="space-y-3">
                <div class="flex items-center gap-3 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <div class="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center">
                    <i class="iconoir-calendar-check text-green-600" aria-hidden="true"></i>
                  </div>
                  <div>
                    <p class="text-sm text-gray-500">This field will be automatically filled with today's date when you submit:</p>
                    <p class="text-lg font-medium text-gray-900 mt-1" id="date-preview-{{ field.id }}"></p>
                  </div>
                </div>
                <p class="text-xs text-gray-500 text-center">
                  <i class="iconoir-info-circle mr-1" aria-hidden="true"></i>
                  Date is set automatically to ensure accuracy
                </p>
              </div>

              {% elif field.type == "text" %}
              <!-- Text Field -->
              <div class="space-y-4">
                <textarea
                  class="field-text-input w-full px-4 py-3 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                  placeholder="{{ field.placeholder|default:'Enter text' }}"
                  rows="3"
                  data-field-id="{{ field.id }}"
                  oninput="handleFieldInput('{{ field.id }}', this.value)"
                  aria-label="Text field"
                >{{ field.value_text }}</textarea>
                <button
                  type="button"
                  class="btn btn-primary w-full justify-center field-apply-btn"
                  data-field-id="{{ field.id }}"
                  onclick="saveTextField('{{ field.id }}')"
                >
                  Apply
                </button>
              </div>

              {% elif field.type == "checkbox" %}
              <!-- Checkbox Field -->
              <div class="space-y-4">
                <label class="flex items-start gap-3 p-4 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors">
                  <input
                    type="checkbox"
                    class="field-checkbox-input w-5 h-5 mt-0.5 rounded border-gray-300 text-blue-600 focus:ring-2 focus:ring-blue-500"
                    data-field-id="{{ field.id }}"
                    {% if field.value_bool %}checked{% endif %}
                    onchange="handleCheckboxChange('{{ field.id }}', this.checked)"
                  />
                  <span class="text-gray-700">{{ field.label|default:"I agree to the terms" }}</span>
                </label>
              </div>
              {% endif %}
            </div>
          </div>
          {% endfor %}

          <!-- Submit Section -->
          <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mt-6" id="submit-section">
            <div class="text-center space-y-4">
              <div class="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto">
                <i class="iconoir-check-circle text-blue-600 text-2xl" aria-hidden="true"></i>
              </div>
              <div>
                <h3 class="text-lg font-semibold text-gray-900">Ready to Submit?</h3>
                <p class="text-sm text-gray-600 mt-1" id="submit-status">
                  Complete all required fields above, then click Submit to finalize your signature.
                </p>
              </div>

              <div id="incomplete-fields-notice" class="hidden bg-amber-50 border border-amber-200 rounded-lg p-4 text-left">
                <p class="text-sm font-medium text-amber-800 mb-2">
                  <i class="iconoir-warning-circle mr-1" aria-hidden="true"></i>
                  Please complete the following required fields:
                </p>
                <ul id="incomplete-fields-list" class="text-sm text-amber-700 space-y-1 ml-5 list-disc"></ul>
              </div>

              <div id="failed-fields-notice" class="hidden bg-red-50 border border-red-200 rounded-lg p-4 text-left">
                <p class="text-sm font-medium text-red-800 mb-2">
                  <i class="iconoir-warning-triangle mr-1" aria-hidden="true"></i>
                  The following fields failed to save. Please retry before submitting:
                </p>
                <ul id="failed-fields-list" class="text-sm text-red-700 space-y-1 ml-5 list-disc"></ul>
                <button
                  type="button"
                  class="mt-3 text-sm font-medium text-red-700 hover:text-red-800 underline underline-offset-2"
                  onclick="retryAllFailedFields()"
                >
                  <i class="iconoir-refresh mr-1" aria-hidden="true"></i>
                  Retry all failed fields
                </button>
              </div>

              <button
                type="button"
                id="submit-btn"
                class="btn btn-primary w-full sm:w-auto px-8 py-3 justify-center text-base disabled:opacity-50 disabled:cursor-not-allowed"
                onclick="handleSubmit()"
                disabled
              >
                <i class="iconoir-send mr-2" aria-hidden="true"></i>
                Submit Signature
              </button>

              <p class="text-xs text-gray-500">
                By clicking Submit, you agree that your signature has the same legal effect as signing in ink.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
{% endblock %}

{% block scripts %}
<script>
  // Configuration
  const signerConfig = {
    token: '{{ token }}',
    apiBasePath: '{{ api_base_path|default:"/api/v1/esign/signing" }}',
    agreementId: '{{ session.agreement_id }}',
    recipientId: '{{ session.recipient_id }}',
    fields: JSON.parse('{{ session.fields_json|escapejs|default:"[]" }}')
  };

  // State
  const fieldState = new Map();
  let activeFieldIndex = 0;
  let signatureCanvases = new Map();
  let initializedCanvases = new Set(); // Track which canvases have been initialized

  // Initialize on load
  document.addEventListener('DOMContentLoaded', function() {
    initializeFields();
    initializeSignatureTabs();
    updateProgress();
    updateSubmitButton();
    updateFailedFieldsNotice();
    showCurrentDate();
  });

  function initializeFields() {
    const fields = document.querySelectorAll('.field-card');
    fields.forEach((card, index) => {
      const fieldId = card.dataset.fieldId;
      const fieldType = card.dataset.fieldType;
      const isRequired = card.dataset.fieldRequired === 'true';

      // Get initial value from DOM
      let value = null;
      if (fieldType === 'checkbox') {
        const checkbox = card.querySelector('.field-checkbox-input');
        value = checkbox?.checked || false;
      } else if (fieldType === 'date_signed') {
        value = new Date().toISOString().split('T')[0]; // Auto-filled
      } else {
        const input = card.querySelector('.field-text-input, .sig-type-input');
        value = input?.value || '';
      }

      fieldState.set(fieldId, {
        id: fieldId,
        type: fieldType,
        required: isRequired,
        value: value,
        completed: Boolean(value),
        signatureType: 'typed', // typed or drawn
        signatureData: null,
        hasError: false,
        lastError: null,
        pendingSave: false
      });

      // Update UI if already completed
      if (value) {
        updateFieldStatus(fieldId, true);
      }
    });
  }

  function initializeSingleCanvas(fieldId) {
    // Skip if already initialized
    if (initializedCanvases.has(fieldId)) {
      return;
    }

    const canvas = document.querySelector(`.sig-canvas[data-field-id="${fieldId}"]`);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    // Set canvas resolution - now the panel is visible so dimensions are correct
    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) {
      // Still not visible, skip initialization
      return;
    }

    canvas.width = rect.width * 2;
    canvas.height = rect.height * 2;
    ctx.scale(2, 2);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#1f2937';

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    const getPos = (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
      const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
      return { x, y };
    };

    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      const pos = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x;
      lastY = pos.y;
    });

    canvas.addEventListener('mouseup', () => { isDrawing = false; });
    canvas.addEventListener('mouseout', () => { isDrawing = false; });

    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDrawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isDrawing) return;
      const pos = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x;
      lastY = pos.y;
    });

    canvas.addEventListener('touchend', () => { isDrawing = false; });

    signatureCanvases.set(fieldId, { canvas, ctx });
    initializedCanvases.add(fieldId);
  }

  function initializeSignatureTabs() {
    const tabBtns = document.querySelectorAll('.sig-tab-btn');
    tabBtns.forEach(btn => {
      btn.addEventListener('click', function() {
        const container = this.closest('.signature-container');
        const targetTab = this.dataset.tab;
        const fieldId = container.dataset.fieldId;

        // Update tab buttons
        container.querySelectorAll('.sig-tab-btn').forEach(b => {
          b.classList.remove('border-blue-600', 'text-blue-600');
          b.classList.add('border-transparent', 'text-gray-500');
          b.setAttribute('aria-selected', 'false');
        });
        this.classList.remove('border-transparent', 'text-gray-500');
        this.classList.add('border-blue-600', 'text-blue-600');
        this.setAttribute('aria-selected', 'true');

        // Update panels
        container.querySelectorAll('.sig-panel').forEach(p => p.classList.add('hidden'));
        container.querySelector(`#sig-${targetTab}-${fieldId}`).classList.remove('hidden');

        // Update field state
        const state = fieldState.get(fieldId);
        if (state) {
          state.signatureType = targetTab === 'draw' ? 'drawn' : 'typed';
        }

        // Lazy initialize canvas when switching to draw tab
        if (targetTab === 'draw') {
          // Use requestAnimationFrame to ensure the panel is rendered before measuring
          requestAnimationFrame(() => {
            initializeSingleCanvas(fieldId);
          });
        }
      });
    });
  }

  function clearSignatureCanvas(fieldId) {
    // Ensure canvas is initialized before clearing
    if (!initializedCanvases.has(fieldId)) {
      initializeSingleCanvas(fieldId);
    }
    const canvasData = signatureCanvases.get(fieldId);
    if (canvasData) {
      const { canvas, ctx } = canvasData;
      // Clear using the scaled dimensions
      ctx.clearRect(0, 0, canvas.width / 2, canvas.height / 2);
    }
  }

  function showCurrentDate() {
    const dateFields = document.querySelectorAll('[id^="date-preview-"]');
    const today = new Date().toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    dateFields.forEach(el => el.textContent = today);
  }

  function scrollToField(fieldId) {
    const card = document.getElementById(`field-${fieldId}`);
    if (card) {
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Update active states
      document.querySelectorAll('.field-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      // Update nav
      document.querySelectorAll('.field-nav-item').forEach(n => {
        n.setAttribute('aria-current', n.dataset.fieldId === fieldId ? 'true' : 'false');
      });
    }
  }

  function handleFieldInput(fieldId, value) {
    const state = fieldState.get(fieldId);
    if (state) {
      state.value = value;
    }
  }

  async function handleCheckboxChange(fieldId, checked) {
    const state = fieldState.get(fieldId);
    if (!state) return;

    state.value = checked;
    state.pendingSave = true;
    clearFieldError(fieldId);

    const saved = await saveFieldValue(fieldId, null, checked);

    state.pendingSave = false;
    if (saved) {
      state.completed = true;
      state.hasError = false;
      state.lastError = null;
      updateFieldStatus(fieldId, true);
    } else {
      state.completed = false;
      state.hasError = true;
      updateFieldErrorStatus(fieldId, true);
    }
    updateProgress();
    updateSubmitButton();
    updateFailedFieldsNotice();
  }

  async function saveTextField(fieldId) {
    const state = fieldState.get(fieldId);
    if (!state) return;

    const input = document.querySelector(`[data-field-id="${fieldId}"].field-text-input, [data-field-id="${fieldId}"].sig-type-input`);
    const value = input?.value?.trim();

    if (!value && state.required) {
      if (window.toastManager) {
        window.toastManager.error('This field is required');
      }
      return;
    }

    state.pendingSave = true;
    clearFieldError(fieldId);

    const saved = await saveFieldValue(fieldId, value, null);

    state.pendingSave = false;
    if (saved) {
      state.value = value;
      state.completed = Boolean(value);
      state.hasError = false;
      state.lastError = null;
      updateFieldStatus(fieldId, state.completed);
      updateProgress();
      updateSubmitButton();
      updateFailedFieldsNotice();
      moveToNextField(fieldId);
    } else {
      state.hasError = true;
      updateFieldErrorStatus(fieldId, true);
      updateSubmitButton();
      updateFailedFieldsNotice();
    }
  }

  async function applySignature(fieldId) {
    const state = fieldState.get(fieldId);
    if (!state) return;

    let signatureData = null;
    let valueText = '';

    if (state.signatureType === 'typed') {
      const input = document.querySelector(`[data-field-id="${fieldId}"].sig-type-input`);
      valueText = input?.value?.trim();
      if (!valueText) {
        if (window.toastManager) {
          window.toastManager.error('Please type your signature');
        }
        return;
      }
      signatureData = { type: 'typed', text: valueText };
    } else {
      // Drawn signature
      const canvasData = signatureCanvases.get(fieldId);
      if (!canvasData) return;

      const { canvas } = canvasData;
      const dataUrl = canvas.toDataURL('image/png');

      // Check if canvas has content
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const hasContent = imageData.data.some((val, i) => i % 4 === 3 && val > 0);

      if (!hasContent) {
        if (window.toastManager) {
          window.toastManager.error('Please draw your signature');
        }
        return;
      }

      signatureData = { type: 'drawn', dataUrl };
      valueText = '[Drawn Signature]';
    }

    state.pendingSave = true;
    clearFieldError(fieldId);

    // Initials are regular text fields in the API contract.
    let saved = false;
    if (state.type === 'initials') {
      saved = await saveFieldValue(fieldId, valueText, null);
    } else {
      saved = await saveSignatureArtifact(fieldId, signatureData, valueText);
    }

    state.pendingSave = false;
    if (saved) {
      state.value = valueText;
      state.signatureData = signatureData;
      state.completed = true;
      state.hasError = false;
      state.lastError = null;
      updateFieldStatus(fieldId, true);
      updateProgress();
      updateSubmitButton();
      updateFailedFieldsNotice();
      moveToNextField(fieldId);
    } else {
      state.hasError = true;
      updateFieldErrorStatus(fieldId, true);
      updateSubmitButton();
      updateFailedFieldsNotice();
    }
  }

  async function saveFieldValue(fieldId, valueText, valueBool) {
    const btn = document.querySelector(`[data-field-id="${fieldId}"].field-apply-btn`);
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '<i class="iconoir-refresh animate-spin mr-2"></i> Saving...';
    }

    const state = fieldState.get(fieldId);

    try {
      const response = await fetch(`${signerConfig.apiBasePath}/field-values/${signerConfig.token}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          field_id: fieldId,
          value_text: valueText,
          value_bool: valueBool
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorMsg = errorData.error?.message || 'Failed to save field';
        if (state) {
          state.lastError = errorMsg;
        }
        throw new Error(errorMsg);
      }

      if (window.toastManager) {
        window.toastManager.success('Field saved');
      }
      return true;
    } catch (error) {
      console.error('Save error:', error);
      if (state) {
        state.lastError = error.message;
      }
      if (window.toastManager) {
        window.toastManager.error(error.message);
      }
      return false;
    } finally {
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = 'Apply';
      }
    }
  }

  function sanitizePathSegment(value) {
    const sanitized = String(value || '')
      .trim()
      .replace(/[^a-zA-Z0-9._-]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return sanitized || 'unknown';
  }

  function bufferToHex(buffer) {
    return Array.from(new Uint8Array(buffer))
      .map(byte => byte.toString(16).padStart(2, '0'))
      .join('');
  }

  function randomHex(length) {
    const chars = '0123456789abcdef';
    let output = '';
    for (let i = 0; i < length; i++) {
      output += chars[Math.floor(Math.random() * chars.length)];
    }
    return output;
  }

  async function sha256Hex(input) {
    const text = String(input || '');
    if (window.crypto && window.crypto.subtle && window.TextEncoder) {
      const bytes = new TextEncoder().encode(text);
      const digest = await window.crypto.subtle.digest('SHA-256', bytes);
      return bufferToHex(digest);
    }
    return randomHex(64);
  }

  async function buildSignaturePayload(fieldId, signatureData, valueText) {
    const signatureType = signatureData?.type === 'drawn' ? 'drawn' : 'typed';
    const agreementID = sanitizePathSegment(signerConfig.agreementId);
    const recipientID = sanitizePathSegment(signerConfig.recipientId);
    const sanitizedFieldID = sanitizePathSegment(fieldId);
    const extension = signatureType === 'drawn' ? 'png' : 'txt';
    const objectKey = `tenant/bootstrap/org/bootstrap/agreements/${agreementID}/signatures/${recipientID}/${sanitizedFieldID}-${Date.now()}.${extension}`;
    const shaInput = signatureType === 'drawn'
      ? signatureData?.dataUrl || ''
      : `${valueText || ''}|${fieldId}`;
    const sha256 = await sha256Hex(shaInput);

    return {
      field_id: fieldId,
      type: signatureType,
      value_text: valueText,
      object_key: objectKey,
      sha256: sha256
    };
  }

  async function saveSignatureArtifact(fieldId, signatureData, valueText) {
    const btn = document.querySelector(`[data-field-id="${fieldId}"].field-apply-btn`);
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '<i class="iconoir-refresh animate-spin mr-2"></i> Saving...';
    }

    const state = fieldState.get(fieldId);

    try {
      const payload = await buildSignaturePayload(fieldId, signatureData, valueText);
      const response = await fetch(`${signerConfig.apiBasePath}/field-values/signature/${signerConfig.token}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorMsg = errorData.error?.message || 'Failed to save signature';
        if (state) {
          state.lastError = errorMsg;
        }
        throw new Error(errorMsg);
      }

      if (window.toastManager) {
        window.toastManager.success('Signature applied');
      }
      return true;
    } catch (error) {
      console.error('Signature error:', error);
      if (state) {
        state.lastError = error.message;
      }
      if (window.toastManager) {
        window.toastManager.error(error.message);
      }
      return false;
    } finally {
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = state?.type === 'initials' ? 'Apply Initials' : 'Apply Signature';
      }
    }
  }

  function updateFieldStatus(fieldId, completed) {
    const card = document.getElementById(`field-${fieldId}`);
    const navItem = document.querySelector(`.field-nav-item[data-field-id="${fieldId}"]`);

    if (card) {
      const completeBadge = card.querySelector('.field-complete-badge');
      // Clear error state when marking complete
      card.classList.remove('error');
      if (completed) {
        card.classList.add('completed');
        completeBadge?.classList.remove('hidden');
        completeBadge?.classList.add('flex');
      } else {
        card.classList.remove('completed');
        completeBadge?.classList.add('hidden');
        completeBadge?.classList.remove('flex');
      }
    }

    if (navItem) {
      const icon = navItem.querySelector('.field-status-icon');
      if (completed) {
        icon.classList.remove('bg-gray-100', 'text-gray-400', 'bg-red-100', 'text-red-600');
        icon.classList.add('bg-green-100', 'text-green-600');
        icon.innerHTML = '<i class="iconoir-check text-sm"></i>';
      }
    }
  }

  function updateFieldErrorStatus(fieldId, hasError) {
    const card = document.getElementById(`field-${fieldId}`);
    const navItem = document.querySelector(`.field-nav-item[data-field-id="${fieldId}"]`);

    if (card) {
      card.classList.remove('completed');
      const completeBadge = card.querySelector('.field-complete-badge');
      completeBadge?.classList.add('hidden');
      completeBadge?.classList.remove('flex');

      if (hasError) {
        card.classList.add('error');
      } else {
        card.classList.remove('error');
      }
    }

    if (navItem) {
      const icon = navItem.querySelector('.field-status-icon');
      if (hasError) {
        icon.classList.remove('bg-gray-100', 'text-gray-400', 'bg-green-100', 'text-green-600');
        icon.classList.add('bg-red-100', 'text-red-600');
        icon.innerHTML = '<i class="iconoir-warning-circle text-sm"></i>';
      }
    }
  }

  function clearFieldError(fieldId) {
    const state = fieldState.get(fieldId);
    if (state) {
      state.hasError = false;
      state.lastError = null;
    }
    const card = document.getElementById(`field-${fieldId}`);
    if (card) {
      card.classList.remove('error');
    }
    const navItem = document.querySelector(`.field-nav-item[data-field-id="${fieldId}"]`);
    if (navItem) {
      const icon = navItem.querySelector('.field-status-icon');
      const state = fieldState.get(fieldId);
      if (state && !state.completed) {
        icon.classList.remove('bg-red-100', 'text-red-600', 'bg-green-100', 'text-green-600');
        icon.classList.add('bg-gray-100', 'text-gray-400');
        const index = navItem.dataset.fieldIndex;
        icon.innerHTML = `<span class="text-xs font-medium">${parseInt(index) + 1}</span>`;
      }
    }
  }

  function updateFailedFieldsNotice() {
    const failedNotice = document.getElementById('failed-fields-notice');
    const failedList = document.getElementById('failed-fields-list');

    const failedFields = [];
    fieldState.forEach((state, fieldId) => {
      if (state.hasError) {
        failedFields.push({ id: fieldId, type: state.type, error: state.lastError });
      }
    });

    if (failedFields.length === 0) {
      failedNotice.classList.add('hidden');
    } else {
      failedNotice.classList.remove('hidden');
      failedList.innerHTML = failedFields.map(f => {
        const label = f.type === 'signature' ? 'Signature' :
                      f.type === 'initials' ? 'Initials' :
                      f.type === 'name' ? 'Full Name' :
                      f.type.charAt(0).toUpperCase() + f.type.slice(1);
        const errorMsg = f.error ? ` - ${f.error}` : '';
        return `<li>
          <a href="#field-${f.id}" onclick="scrollToField('${f.id}'); return false;" class="underline hover:no-underline">${label}</a>
          <span class="text-red-500 text-xs">${errorMsg}</span>
        </li>`;
      }).join('');
    }
  }

  function moveToNextField(currentFieldId) {
    const fields = Array.from(document.querySelectorAll('.field-card'));
    const currentIndex = fields.findIndex(f => f.dataset.fieldId === currentFieldId);

    // Find next incomplete required field
    for (let i = currentIndex + 1; i < fields.length; i++) {
      const fieldId = fields[i].dataset.fieldId;
      const state = fieldState.get(fieldId);
      if (state && state.required && !state.completed) {
        scrollToField(fieldId);
        return;
      }
    }

    // Check if any required fields before current are incomplete
    for (let i = 0; i < currentIndex; i++) {
      const fieldId = fields[i].dataset.fieldId;
      const state = fieldState.get(fieldId);
      if (state && state.required && !state.completed) {
        scrollToField(fieldId);
        return;
      }
    }

    // All required fields complete - scroll to submit
    document.getElementById('submit-section').scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  function updateProgress() {
    let completed = 0;
    let total = 0;

    fieldState.forEach(state => {
      if (state.required || state.completed) {
        total++;
        if (state.completed) completed++;
      }
    });

    // Update count display
    document.getElementById('completed-count').textContent = completed;
    document.getElementById('total-count').textContent = fieldState.size;

    // Update progress bar
    const percentage = fieldState.size > 0 ? (completed / fieldState.size) * 100 : 0;
    const progressBar = document.getElementById('progress-bar');
    progressBar.style.width = `${percentage}%`;
    progressBar.parentElement.setAttribute('aria-valuenow', Math.round(percentage));
  }

  function updateSubmitButton() {
    const submitBtn = document.getElementById('submit-btn');
    const incompleteNotice = document.getElementById('incomplete-fields-notice');
    const incompleteList = document.getElementById('incomplete-fields-list');

    let incompleteRequired = [];
    let hasFailedFields = false;
    let hasPendingSaves = false;

    fieldState.forEach((state, fieldId) => {
      if (state.required && !state.completed) {
        incompleteRequired.push({ id: fieldId, type: state.type });
      }
      if (state.hasError) {
        hasFailedFields = true;
      }
      if (state.pendingSave) {
        hasPendingSaves = true;
      }
    });

    const statusEl = document.getElementById('submit-status');

    if (hasPendingSaves) {
      submitBtn.disabled = true;
      statusEl.textContent = 'Saving fields...';
    } else if (hasFailedFields) {
      submitBtn.disabled = true;
      statusEl.textContent = 'Please retry failed fields before submitting.';
    } else if (incompleteRequired.length === 0) {
      submitBtn.disabled = false;
      incompleteNotice.classList.add('hidden');
      statusEl.textContent = 'All fields complete. Click Submit to finalize your signature.';
    } else {
      submitBtn.disabled = true;
      incompleteNotice.classList.remove('hidden');
      incompleteList.innerHTML = incompleteRequired.map(f => {
        const label = f.type === 'signature' ? 'Signature' :
                      f.type === 'initials' ? 'Initials' :
                      f.type === 'name' ? 'Full Name' :
                      f.type.charAt(0).toUpperCase() + f.type.slice(1);
        return `<li><a href="#field-${f.id}" onclick="scrollToField('${f.id}'); return false;" class="underline hover:no-underline">${label}</a></li>`;
      }).join('');
    }
  }

  async function retryField(fieldId) {
    const state = fieldState.get(fieldId);
    if (!state) return;

    scrollToField(fieldId);

    // Re-trigger the appropriate save action based on field type
    if (state.type === 'checkbox') {
      const checkbox = document.querySelector(`[data-field-id="${fieldId}"].field-checkbox-input`);
      if (checkbox) {
        await handleCheckboxChange(fieldId, checkbox.checked);
      }
    } else if (state.type === 'signature') {
      await applySignature(fieldId);
    } else if (state.type === 'initials') {
      await applySignature(fieldId);
    } else {
      await saveTextField(fieldId);
    }
  }

  async function retryAllFailedFields() {
    const failedFieldIds = [];
    fieldState.forEach((state, fieldId) => {
      if (state.hasError) {
        failedFieldIds.push(fieldId);
      }
    });

    if (failedFieldIds.length === 0) return;

    if (window.toastManager) {
      window.toastManager.info(`Retrying ${failedFieldIds.length} failed field(s)...`);
    }

    // Retry each field sequentially to avoid overwhelming the server
    for (const fieldId of failedFieldIds) {
      await retryField(fieldId);
      // Small delay between retries
      await new Promise(resolve => setTimeout(resolve, 300));
    }
  }

  async function validateSessionBeforeSubmit() {
    try {
      const response = await fetch(`${signerConfig.apiBasePath}/session/${signerConfig.token}`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorCode = errorData.error?.code;

        // Handle specific error codes
        if (errorCode === 'TOKEN_EXPIRED') {
          throw new Error('Your signing session has expired. Please request a new signing link.');
        } else if (errorCode === 'TOKEN_INVALID') {
          throw new Error('Your signing session is no longer valid.');
        } else if (errorCode === 'AGREEMENT_IMMUTABLE') {
          throw new Error('This agreement has already been completed or is no longer available for signing.');
        }
        throw new Error(errorData.error?.message || 'Failed to validate session');
      }

      const data = await response.json();
      const session = data.session || data;

      // Check if session state is still active
      if (session.state === 'waiting') {
        throw new Error('Another signer must complete before you. Please wait for your turn.');
      } else if (session.state === 'completed') {
        throw new Error('You have already completed signing this document.');
      } else if (session.state === 'terminal') {
        throw new Error('This agreement is no longer available for signing.');
      } else if (session.state !== 'active') {
        throw new Error('Your signing session is not in a valid state.');
      }

      // Validate all required fields are completed on server
      const serverFields = session.fields || [];
      const incompleteServerFields = [];

      for (const field of serverFields) {
        if (field.required) {
          const hasValue = field.value_text || field.value_bool || field.artifact_id;
          if (!hasValue) {
            incompleteServerFields.push(field);
          }
        }
      }

      if (incompleteServerFields.length > 0) {
        // Sync local state with server state
        for (const field of incompleteServerFields) {
          const state = fieldState.get(field.id);
          if (state && state.completed) {
            // Local state says complete but server says incomplete
            state.completed = false;
            state.hasError = true;
            state.lastError = 'Field value was not saved properly';
            updateFieldErrorStatus(field.id, true);
          }
        }
        updateProgress();
        updateSubmitButton();
        updateFailedFieldsNotice();
        throw new Error(`${incompleteServerFields.length} required field(s) are not saved on server. Please retry.`);
      }

      return true;
    } catch (error) {
      console.error('Session validation error:', error);
      throw error;
    }
  }

  async function handleSubmit() {
    const submitBtn = document.getElementById('submit-btn');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="iconoir-refresh animate-spin mr-2"></i> Validating...';

    try {
      // Pre-submit validation: check session state and server-side field completion
      await validateSessionBeforeSubmit();

      submitBtn.innerHTML = '<i class="iconoir-refresh animate-spin mr-2"></i> Submitting...';

      const idempotencyKey = `submit-${sanitizePathSegment(signerConfig.recipientId)}-${Date.now()}`;
      const response = await fetch(`${signerConfig.apiBasePath}/submit/${signerConfig.token}`, {
        method: 'POST',
        headers: { 'Idempotency-Key': idempotencyKey }
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorCode = errorData.error?.code;

        // Handle specific error codes with user-friendly messages
        if (errorCode === 'MISSING_REQUIRED_FIELDS') {
          // Trigger session refresh to sync state
          await validateSessionBeforeSubmit().catch(() => {});
          throw new Error('Some required fields are missing. Please complete all fields and try again.');
        } else if (errorCode === 'CONSENT_REQUIRED') {
          throw new Error('Please accept the consent agreement before submitting.');
        } else if (errorCode === 'INVALID_SIGNER_STATE') {
          throw new Error('Your signing session state has changed. Please refresh the page.');
        }

        throw new Error(errorData.error?.message || 'Failed to submit');
      }

      // Redirect to confirmation page
      window.location.href = signerConfig.apiBasePath.replace('/api/v1/esign/signing', '/esign/sign') + '/' + signerConfig.token + '/complete';
    } catch (error) {
      console.error('Submit error:', error);
      if (window.toastManager) {
        window.toastManager.error(error.message);
      }
      submitBtn.disabled = false;
      submitBtn.innerHTML = '<i class="iconoir-send mr-2"></i> Submit Signature';
    }
  }

  // Open document preview - only use binary asset URLs, never contract_url (which returns JSON)
  async function openDocumentPreview() {
    try {
      const response = await fetch(`${signerConfig.apiBasePath}/assets/${signerConfig.token}`, {
        method: 'GET'
      });
      if (!response.ok) {
        throw new Error('Document preview unavailable');
      }
      const payload = await response.json();
      const assets = payload?.assets || {};

      // Only use concrete binary asset URLs - never fall back to contract_url which is JSON
      const previewPath = assets.source_url || assets.executed_url || assets.certificate_url;

      if (!previewPath) {
        // If no binary URL is available, show helpful error with guidance
        const errorMsg = 'Document preview is not available yet. The document may still be processing. Please try again in a moment or contact the sender for assistance.';
        throw new Error(errorMsg);
      }

      const previewURL = new URL(previewPath, window.location.origin).toString();
      window.open(previewURL, '_blank', 'width=900,height=700');
    } catch (error) {
      console.error('Preview error:', error);
      if (window.toastManager) {
        window.toastManager.error(error.message || 'Unable to open document preview');
      }
    }
  }
</script>

<style>
  .font-signature {
    font-family: 'Brush Script MT', 'Segoe Script', cursive;
  }
</style>
{% endblock %}
