#!/bin/bash

# Check for -debug flag
if [[ $* == *-debug* ]]; then
    set -x
fi

export LGR_NO_TIMESTAMP=true

VERSION_FILE="./.version"
GO_BIN="/Users/goliatone/.g/go/bin/go"

# If we have a .taskenv file load it as source
if [ -f .taskenv ]; then
    # shellcheck disable=SC1091
    source .taskenv
fi

# This makes all bin packages installed via npm available here
# e.g. bogota, nyc, autocannon, etc.
PATH=$(pwd)/node_modules/.bin:$PATH

# This will make all scripts available in the ./src/bin directory
PATH=$(pwd)/src/bin:$PATH


##########################################
# Application management
##########################################


function dev:test {
    "${GO_BIN}" test ./...
}

function dev:cover {
    "${GO_BIN}" test -coverprofile=coverage.out ./... && "${GO_BIN}" tool cover -func coverage.out
}

function dev:serve {
    local root_dir
    root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
    local assets_dir="${root_dir}/pkg/client/assets"
    local hash_file="${assets_dir}/.build_hash"
    local src_dir="${assets_dir}/src"

    # Calculate hash of source files
    local current_hash
    if command -v md5sum &> /dev/null; then
        # Linux
        current_hash=$(find "${src_dir}" -type f \( -name "*.ts" -o -name "*.css" -o -name "*.js" \) -exec md5sum {} \; 2>/dev/null | sort | md5sum | cut -d' ' -f1)
    else
        # macOS
        current_hash=$(find "${src_dir}" -type f \( -name "*.ts" -o -name "*.css" -o -name "*.js" \) -exec md5 -q {} \; 2>/dev/null | sort | md5 -q)
    fi

    # Check if build is needed
    local needs_build=1
    if [ -f "$hash_file" ] && [ -d "${assets_dir}/dist" ]; then
        local stored_hash
        stored_hash=$(cat "$hash_file" 2>/dev/null)
        if [ "$stored_hash" = "$current_hash" ]; then
            needs_build=0
            echo "Assets unchanged, skipping build"
        fi
    fi

    if [ "$needs_build" -eq 1 ]; then
        echo "Building assets..."
        (cd "${assets_dir}" && lgr exec -- npm run build)
        local build_status=$?
        if [ "$build_status" -ne 0 ]; then
            lgr error "npm build failed with status $build_status"
            return "$build_status"
        fi
        # Store hash after successful build
        echo "$current_hash" > "$hash_file"
    fi

    export ENV=development;
    export RESET_NAV_MENU=true;
    export ADMIN_DEBUG=true;
    export ADMIN_SEEDS=false;
    export ADMIN_ASSETS_DEBUG=1;
    export ADMIN_PUBLIC_API=true;
    export ADMIN_API_VERSION=v1;
    export ESIGN_FEATURE_ENABLED=true;
    export ESIGN_GOOGLE_FEATURE_ENABLED=true;
    export ESIGN_GOOGLE_PROVIDER_MODE=deterministic;
    export ESIGN_GOOGLE_CREDENTIAL_ACTIVE_KEY="eSjaEfrhedRicmBvaHHGrPWwVetQ35yf0mLG3VZ6K/4=";
    export ESIGN_EMAIL_TRANSPORT=mailpit;
    export ESIGN_EMAIL_SMTP_HOST=localhost;
    export ESIGN_SIGNER_FLOW_MODE=unified;
    export ESIGN_EMAIL_SMTP_PORT=1025;
    export ESIGN_EMAIL_SMTP_DISABLE_STARTTLS=true;
    export ESIGN_EMAIL_SMTP_USERNAME=User1;
    export ESIGN_EMAIL_SMTP_PASSWORD=Password1;
    export ADMIN_ASSETS_DIR="${root_dir}/pkg/client/assets"

    "${GO_BIN}" run .
}

# Force rebuild assets, bypassing hash check
function dev:serve:rebuild {
    local root_dir
    root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
    local assets_dir="${root_dir}/pkg/client/assets"

    # Remove hash file to force rebuild
    rm -f "${assets_dir}/.build_hash"

    dev:serve
}

function release:verify {
    "${GO_BIN}" test ./release -run 'TestChecklistValidateRejectsUnapprovedSignoffs|TestChecklistValidatePassesForApprovedChecklist|TestValidateChecklistFileTemplateShowsPendingApprovals|TestChecklistValidateRejectsAPIOnlyFallback|TestChecklistValidateRejectsMissingProductizationAssertions|TestRunValidationProfilePassesSLOGates'
}

function smoke:e2e {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    "${script_dir}/smoke_e2e.sh" "$@"
}

##
## ########################################
##           Version Management
## ########################################

##
## -----
##
## version:upsert
##
## Save version to meta file.
## First time will create file if not present
##
## Arguments:
## @arg 1 {string} [tag=0.0.1]
function version:upsert {
    local tag=${1}

    if [ -z "$tag" ]; then
        version:get
    else
        version:set "$tag"
        version:get
    fi
}

##
## -----
##
## version:get
##
## Get version from meta file.
function version:get {

    test -f "${VERSION_FILE}" || touch "${VERSION_FILE}"

    local tag
    tag=$(cat "${VERSION_FILE}")

    if [ -z "$tag" ]; then
        tag="0.0.1"
        version:set "$tag"
    fi

    echo -n "$tag"
}

##
## -----
##
## version:set
##
## Set and save version to meta file.
## First time will create file if not present.
##
## Arguments:
## @arg 1 {string} [tag=0.0.1]
function version:set {

    local tag
    tag=${1}
    if [ -z "$tag" ]; then
        exit 1
    fi

    version:check

    echo -e "$tag" > "${VERSION_FILE}"
}

##
## -----
##
## version:bump
## Bump sem ver by specifying a level.
## Valid levels are:
## - patch (default)
## - minor
## - major
##
## If you want to update the .version file
## pass the `--write` flag.
## @see https://github.com/fsaintjacques/semver-tool/blob/master/src/semver
##
## @arg 1 {string} [level=patch]
## Outputs:
##   Semver string "$major.$minor.$patch"
##
## @flag --write Will write to .version file
##
function version:bump {

    version:check

    # Default values
    level='patch'
    write_to_file=0

    # Parse options
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --write)
                write_to_file=1
                shift
            ;;
            patch|minor|major)
                level=$1
                shift
            ;;
            *)
                echo "Invalid option: $1"
                return 2
            ;;
        esac
    done

    # Read contents of version and store in
    IFS='.' read -ra identifiers < "$VERSION_FILE"

    [[ "${#identifiers[@]}" -ne 3 ]] && echo "Invalid semver string" && return 1

    patch=${identifiers[2]}
    minor=${identifiers[1]}
    major=${identifiers[0]}

    case $level in
        patch)
            patch=$((patch+1))
        ;;
        minor)
            minor=$((minor+1))
            patch=0
        ;;
        major)
            major=$((major+1))
            minor=0
            patch=0
        ;;
        *)
            echo "Invalid level passed"
            return 2
    esac

    new_version="$major.$minor.$patch"

    if [[ $write_to_file -eq 1 ]]; then
        echo "$new_version" > "${VERSION_FILE}"
    else
        echo "$new_version"
    fi
}

function version:check {
    if [ ! -f "$VERSION_FILE" ]; then
        echo "0.0.0" > "$VERSION_FILE"
    fi
}


##
## -----
##
## release
##
## Bump our current version, create a git tag
## and push to trigger our release flow.
##
## Arguments:
## @arg 1 {string} [level=patch]
##        Accepted major, minor, patch
function release {
    local tag
    local level
    local message

    release:verify || return $?

    # Fetch all changes from origin
    git fetch --all
    # Make sure we have the latest version file
    git checkout origin/main -- ".version"

    # Pull tags to make sure we have
    git pull --tags -f

    level=${1:-"patch"}

    # Bump our version
    tag=$(version:bump "${level}")

    # Set message: default to New major|minor|patch release: vx.x.x
    message=${2:-"New ${level} release: v${tag}"}

    # Update version file
    version:set "${tag}"

    # Add updated version file to git
    git add "${VERSION_FILE}"

    # Commit changes
    git commit -m "Bump version: v${tag}"

    # Create a new tag
    git tag -a "v${tag}" -m "${message}"

    # Push tags and trigger release ðŸš€ ðŸ¥³
    git push --tags
    git push

    # Generate changelog
    git cliff --output CHANGELOG.md
    git add CHANGELOG.md
    git commit -m "docs: update changelog for v${tag}"

    git push
}

##########################################
# Help and auxiliary functions
##########################################

## Show function code
function help:show {
    declare -f "$1"
}

function help {
    echo ""
    echo "$0 <task> [...arguments]"
    echo ""
    echo "Project: ${PROJECT}"
    echo ""
    echo "Tasks:"
    compgen -A function | grep -v '^_' | cat -n
    echo ""

    prog="$0"
    me=$(basename "$prog")

    grep -e '^##[[:space:]]' -e '^##$' "$prog" | sed -e 's/^##//' -e "s/_PROG_/$me/" 2>&1 | less
}

TIMEFORMAT="Task completed in %3lR"
time "${@:-help}"; exit $?
