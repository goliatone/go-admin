#!/bin/bash

# Check for -debug flag
if [[ $* == *-debug* ]]; then
    set -x
fi

export LGR_NO_TIMESTAMP=true

GO_BIN="/Users/goliatone/.g/go/bin/go"

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# If we have a .taskenv file load it as source
if [ -f .taskenv ]; then
    # shellcheck disable=SC1091
    source .taskenv
fi

# This will make all scripts available in the ./src/bin directory
PATH=$(pwd)/bin:$PATH


##########################################
# Application management
##########################################
function _install:mailpit {
    local BIN_DIR="${SCRIPT_DIR}/bin"

    lgr I "Create dir ${BIN_DIR}..."

    # Create bin directory if it doesn't exist
    mkdir -p "${BIN_DIR}"


    # Check if already installed
    if [[ -x "${BIN_DIR}/mailpit" ]]; then
        lgr OK "mailpit already installed..."
        return 0
    fi

    lgr I "Installing mailpit to ${BIN_DIR}"

    local os="darwin"
    local arch="arm64"
    local version="1.18.3"
    local BIN_URL="https://github.com/axllent/mailpit/releases/download/v${version}/mailpit-${os}-${arch}.tar.gz"
    local TMP_ZIP="${TMPDIR:-/tmp}/mailpit.tar.gz"

    curl --silent --show-error --location --fail "$BIN_URL" --output "${TMP_ZIP}" &&
    tar -xvf "${TMP_ZIP}" -C "${BIN_DIR}" mailpit &&
    chmod +x "${BIN_DIR}/mailpit" &&
    lgr OK "mailpit installed to ${BIN_DIR}/mailpit"

    if [[ -x "${BIN_DIR}/mailpit/development.txt" ]]; then
        return 0
    fi

    dev:smtp:init
}

function dev:install {
    _install:mailpit
    lgr ok "dependencies intalled..."
}

function dev:test {
    "${GO_BIN}" test ./...
}

function dev:cover {
    "${GO_BIN}" test -coverprofile=coverage.out ./... && "${GO_BIN}" tool cover -func coverage.out
}

function dev:serve {
    local root_dir
    root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
    local assets_dir="${root_dir}/pkg/client/assets"
    local hash_file="${assets_dir}/.build_hash"
    local src_dir="${assets_dir}/src"

    # Calculate hash of all frontend inputs that affect runtime behavior:
    # - Source files (TS/CSS/JS)
    # - Build config files (vite, tsconfig, tailwind, package.json)
    # - Input CSS for Tailwind
    local current_hash
    local config_files="${assets_dir}/vite.config.ts ${assets_dir}/tsconfig.json ${assets_dir}/tailwind.config.cjs ${assets_dir}/package.json ${assets_dir}/input.css"

    if command -v md5sum &> /dev/null; then
        # Linux
        current_hash=$(
            {
                find "${src_dir}" -type f \( -name "*.ts" -o -name "*.css" -o -name "*.js" \) -exec md5sum {} \; 2>/dev/null
                for f in $config_files; do [ -f "$f" ] && md5sum "$f" 2>/dev/null; done
            } | sort | md5sum | cut -d' ' -f1
        )
    else
        # macOS
        current_hash=$(
            {
                find "${src_dir}" -type f \( -name "*.ts" -o -name "*.css" -o -name "*.js" \) -exec md5 -q {} \; 2>/dev/null
                for f in $config_files; do [ -f "$f" ] && md5 -q "$f" 2>/dev/null; done
            } | sort | md5 -q
        )
    fi

    # Check if build is needed
    local needs_build=1
    if [ -f "$hash_file" ] && [ -d "${assets_dir}/dist" ]; then
        local stored_hash
        stored_hash=$(cat "$hash_file" 2>/dev/null)
        if [ "$stored_hash" = "$current_hash" ]; then
            needs_build=0
            echo "Assets unchanged, skipping build"
        fi
    fi

    # Safeguard: verify expected dist outputs exist even if hash matches
    if [ "$needs_build" -eq 0 ]; then
        local expected_outputs=(
            "${assets_dir}/dist/datatable/index.js"
            "${assets_dir}/dist/output.css"
            "${assets_dir}/dist/styles/datatable-actions.css"
        )
        for output in "${expected_outputs[@]}"; do
            if [ ! -f "$output" ]; then
                echo "Warning: Expected dist output missing: $output"
                echo "Forcing rebuild..."
                needs_build=1
                break
            fi
        done
    fi

    if [ "$needs_build" -eq 1 ]; then
        echo "Building assets..."
        (cd "${assets_dir}" && lgr exec -- npm run build)
        local build_status=$?
        if [ "$build_status" -ne 0 ]; then
            lgr error "npm build failed with status $build_status"
            return "$build_status"
        fi
        # Store hash after successful build
        echo "$current_hash" > "$hash_file"
    fi

    export ENV=development;
    export RESET_NAV_MENU=true;
    export ADMIN_DEBUG=true;
    export ADMIN_SEEDS=false;
    export ADMIN_ASSETS_DEBUG=1;
    export ADMIN_PUBLIC_API=true;
    export ADMIN_API_VERSION=v1;
    export ESIGN_FEATURE_ENABLED=true;
    export ESIGN_EMAIL_TRANSPORT=mailpit;
    export ESIGN_EMAIL_SMTP_HOST=localhost;
    export ESIGN_SIGNER_FLOW_MODE=unified;
    export ESIGN_EMAIL_SMTP_PORT=1025;
    export ESIGN_EMAIL_SMTP_DISABLE_STARTTLS=true;
    export ESIGN_EMAIL_SMTP_USERNAME=User1;
    export ESIGN_EMAIL_SMTP_PASSWORD=Password1;


	export ESIGN_GOOGLE_FEATURE_ENABLED=true;
	export ESIGN_SERVICES_MODULE_ENABLED=true;
	export ESIGN_GOOGLE_PROVIDER_MODE=real;
	export ESIGN_GOOGLE_CLIENT_ID="${APP_PROVIDERS__GOOGLE__CLIENT_ID}";
	export ESIGN_GOOGLE_CLIENT_SECRET="${APP_PROVIDERS__GOOGLE__CLIENT_SECRET}";
	if [ -z "${ESIGN_SERVICES_ENCRYPTION_KEY:-}" ]; then
	    echo "Missing ESIGN_SERVICES_ENCRYPTION_KEY. Define it in examples/esign/.taskenv to keep credentials decryptable across restarts."
	    return 1
	fi
	if [ -z "${ESIGN_GOOGLE_OAUTH_REDIRECT_URI:-}" ]; then
	    echo "Missing ESIGN_GOOGLE_OAUTH_REDIRECT_URI. Set it to your authorized callback, e.g. http://127.0.0.1:8082/admin/esign/integrations/google/callback"
	    return 1
	fi


    #TODO: remove when we fix go-admin
    export ADMIN_ROUTE_CONFLICT_POLICY="log_and_continue";
    export ADMIN_STRICT_ROUTES=false;
    export ADMIN_ERROR_EXPOSE_INTERNAL=true

    export ADMIN_ASSETS_DIR="${root_dir}/pkg/client/assets"

    "${GO_BIN}" run .
}

# Force rebuild assets, bypassing hash check
function dev:serve:rebuild {
    local root_dir
    root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
    local assets_dir="${root_dir}/pkg/client/assets"

    # Remove hash file to force rebuild
    rm -f "${assets_dir}/.build_hash"

    dev:serve
}

function dev:smtp {
    lgr I "starting SMTP server..."
    lgr W "more info at https://github.com/axllent/mailpit"
    lgr OK "http://0.0.0.0:8025"
    mailpit \
        --smtp-auth-allow-insecure \
        --smtp-tls-cert "$SCRIPT_DIR/ops/mailpit/pub_cert.pem" \
        --smtp-tls-key "$SCRIPT_DIR/ops/mailpit/priv_key.pem" \
        --ui-auth-file "$SCRIPT_DIR/ops/mailpit/development.txt" \
        --smtp-auth-file "$SCRIPT_DIR/ops/mailpit/development.txt"
}

function dev:smtp:init {
    mkdir -p "$SCRIPT_DIR/ops/mailpit"
    openssl req -x509 -newkey rsa:4096 -nodes \
        -keyout "$SCRIPT_DIR/ops/mailpit/priv_key.pem" \
        -out "$SCRIPT_DIR/ops/mailpit/pub_cert.pem" \
        -sha256 -days 3650

    echo 'User1:$2y$05$lvT6Z111jzakwt2mmmmeZOi64AqK3vpzilT5mRYTzXHxLZgSfe4Pm' > "$SCRIPT_DIR/ops/mailpit/development.txt"
}

function release:verify {
    "${GO_BIN}" test ./release -run 'TestChecklistValidateRejectsUnapprovedSignoffs|TestChecklistValidatePassesForApprovedChecklist|TestValidateChecklistFileTemplateShowsPendingApprovals|TestChecklistValidateRejectsAPIOnlyFallback|TestChecklistValidateRejectsMissingProductizationAssertions|TestRunValidationProfilePassesSLOGates|TestSmokeE2EUsesRuntimeIssuedRecipientLinks|TestRunV2ValidationProfilePassesGates|TestEvaluateV2SLODetectsFailures|TestValidateV2ContractFreezeGuardPassesForCurrentSnapshot|TestValidateV2ContractFreezeGuardBlocksPostFreezeMismatchWithoutApproval|TestValidateV2ContractFreezeGuardAllowsApprovedPostFreezeException'
}

function smoke:e2e {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    "${script_dir}/smoke_e2e.sh" "$@"
}

##########################################
# Help and auxiliary functions
##########################################

## Show function code
function help:show {
    declare -f "$1"
}

function help {
    echo ""
    echo "$0 <task> [...arguments]"
    echo ""
    echo "Project: ${PROJECT}"
    echo ""
    echo "Tasks:"
    compgen -A function | grep -v '^_' | cat -n
    echo ""

    prog="$0"
    me=$(basename "$prog")

    grep -e '^##[[:space:]]' -e '^##$' "$prog" | sed -e 's/^##//' -e "s/_PROG_/$me/" 2>&1 | less
}

TIMEFORMAT="Task completed in %3lR"
time "${@:-help}"; exit $?
