#!/bin/bash

# Check for -debug flag
if [[ $* == *-debug* ]]; then
    set -x
fi

export LGR_NO_TIMESTAMP=true

VERSION_FILE="./.version"

# If we have a .taskenv file load it as source
if [ -f .taskenv ]; then
    # shellcheck disable=SC1091
    source .taskenv
fi

# This makes all bin packages installed via npm available here
# e.g. bogota, nyc, autocannon, etc.
PATH=$(pwd)/node_modules/.bin:$PATH

# This will make all scripts available in the ./src/bin directory
PATH=$(pwd)/src/bin:$PATH


#################################################
# Development dependencies
#################################################

function _install:lgr {
    mkdir -p bin
    if hash lgr 2>/dev/null; then
        lgr OK "lgr already installed..."
    else
        echo "Installing lgr"
        brew tap goliatone/homebrew-tap
        brew install lgr
        lgr OK "lgr installed..."
    fi
}

function _install:changelog {
    if git-cliff lgr 2>/dev/null; then
        lgr OK "git-cliff already installed..."
    else
        echo "Installing lgr"
        brew install brew install orhun/git-cliff/git-cliff
        lgr OK "git-cliff installed..."
    fi
}

function _install:brew {
    if [[ $(command -v brew) == "" ]]; then
        lgr I "Installing Hombrew"
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    else
        lgr I "Updating Homebrew"
        brew update
    fi
}

function _install:envset {
    if hash envset 2>/dev/null; then
        lgr OK "envset installed..."
    else
        lgr I "Installing envset..."
        brew install envset
        lgr OK "envset installed..."
    fi
}

##########################################
# Application management
##########################################

function dev:install {
    cd "$(pwd)/src" || exit "$?"

    _install:lgr
    _install:brew

    _install:envset
    _install:changelog

    lgr ok "dependencies intalled..."
}

function dev:env:load {
    eval "$(envset development --isolated=true)"
}

function dev:test {
    go test ./...
}

function dev:test:verbose {
    go test ./... -v -cms-test-logs
}

function dev:verify:services:frontend {
    ./tools/check_services_frontend_contract.sh
}

function dev:race {
    go test ./... -race -count=1
}

function dev:cover {
    go test -coverprofile=coverage.out ./... && go tool cover -func coverage.out
}

##
## -----
##
## release:contracts:refresh
##
## Recompute and persist esign contract guard snapshots and
## synchronize the required Track C ledger entry hash marker.
function release:contracts:refresh {
    local repo_root
    local go_bin

    repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if command -v go >/dev/null 2>&1; then
        go_bin="$(command -v go)"
    elif [ -x "/Users/goliatone/.g/go/bin/go" ]; then
        go_bin="/Users/goliatone/.g/go/bin/go"
    else
        echo "go binary not found in PATH or /Users/goliatone/.g/go/bin/go"
        return 1
    fi

    (
        cd "${repo_root}" || exit "$?"

        local refresh_script
        mkdir -p "${repo_root}/.tmp"
        refresh_script="${repo_root}/.tmp/release_contract_refresh.$$.$RANDOM.go"

        cat > "${refresh_script}" <<'EOF'
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/goliatone/go-admin/examples/esign/release"
)

func writeJSON(path string, value any) error {
	raw, err := json.MarshalIndent(value, "", "  ")
	if err != nil {
		return err
	}
	raw = append(raw, '\n')
	return os.WriteFile(path, raw, 0644)
}

func updateLedgerHash(path, entryID, hash string) error {
	raw, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	text := string(raw)
	heading := "## " + strings.TrimSpace(entryID)
	start := strings.Index(text, heading)
	if start < 0 {
		return fmt.Errorf("track c ledger entry not found: %s", entryID)
	}

	sectionEnd := len(text)
	rest := text[start+len(heading):]
	if next := strings.Index(rest, "\n## "); next >= 0 {
		sectionEnd = start + len(heading) + next
	}

	section := text[start:sectionEnd]
	hashLine := "contract_hash: " + hash
	linePattern := regexp.MustCompile(`(?m)^contract_hash:\s*.*$`)
	if linePattern.MatchString(section) {
		section = linePattern.ReplaceAllString(section, hashLine)
	} else {
		if !strings.HasSuffix(section, "\n") {
			section += "\n"
		}
		section += hashLine + "\n"
	}

	updated := text[:start] + section + text[sectionEnd:]
	return os.WriteFile(path, []byte(updated), 0644)
}

func main() {
	repoRoot, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	trackCPath := filepath.Join(repoRoot, "examples/esign/release/trackc_contract_guard.json")
	trackC, err := release.LoadTrackCContractGuard(trackCPath)
	if err != nil {
		panic(err)
	}
	trackCHash, err := release.ComputeContractShapeHash(repoRoot, trackC.TrackedFiles)
	if err != nil {
		panic(err)
	}
	trackC.ContractHash = trackCHash
	if err := writeJSON(trackCPath, trackC); err != nil {
		panic(err)
	}

	ledgerPath := filepath.Join(repoRoot, filepath.FromSlash(strings.TrimSpace(trackC.LedgerPath)))
	if err := updateLedgerHash(ledgerPath, trackC.RequiredLedgerEntryID, trackCHash); err != nil {
		panic(err)
	}

	v2Path := filepath.Join(repoRoot, "examples/esign/release/v2_contract_freeze_guard.json")
	v2Guard, err := release.LoadV2ContractFreezeGuard(v2Path)
	if err != nil {
		panic(err)
	}
	v2Hash, err := release.ComputeContractShapeHash(repoRoot, v2Guard.TrackedFiles)
	if err != nil {
		panic(err)
	}
	v2Guard.ContractHash = v2Hash
	if err := writeJSON(v2Path, v2Guard); err != nil {
		panic(err)
	}

	fmt.Println("updated trackc guard hash:", trackCHash)
	fmt.Println("updated v2 freeze guard hash:", v2Hash)
	fmt.Println("updated trackc ledger entry:", trackC.RequiredLedgerEntryID)
}
EOF

        "${go_bin}" run "${refresh_script}" || {
            rm -f "${refresh_script}"
            exit 1
        }
        rm -f "${refresh_script}"

        "${go_bin}" test ./examples/esign/release -run 'TestValidateTrackCContractGuardPassesForCurrentSnapshot|TestValidateV2ContractFreezeGuardPassesForCurrentSnapshot' -count=1
    )
}

function go:mod:update {
    local modules
    local extra=()
    local mod
    local root
    local latest
    local root_latest
    local resolved
    local current_mod

    if ! command -v rg >/dev/null 2>&1; then
        lgr ERR "rg is required to list goliatone modules"
        return 1
    fi

    # Get current module name to exclude from updates (avoid self-update and submodules)
    current_mod=$(go list -m)

    modules=$(rg -o 'github.com/goliatone/[^[:space:]]+' go.mod | sort -u | grep -v "^${current_mod}")
    if [ -z "$modules" ]; then
        lgr ERR "no goliatone modules found in go.mod"
        return 1
    fi

    lgr I "updating goliatone modules to latest..."
    for mod in $modules; do
        latest=""
        resolved=0
        if latest=$(go list -m -u -f '{{if .Update}}{{.Update.Version}}{{else}}{{.Version}}{{end}}' "$mod" 2>/dev/null); then
            resolved=1
        fi

        if [ "$resolved" -eq 1 ] && [ -n "$latest" ]; then
            lgr I "go get ${mod}@${latest}"
            go get "${mod}@${latest}" || return 1
            continue
        fi

        lgr WARN "failed to resolve latest for ${mod}, trying ${mod}@latest"
        if go get -u "${mod}@latest"; then
            continue
        fi

        root=$(echo "$mod" | awk -F/ '{print $1"/"$2"/"$3}')
        if [ "$root" != "$mod" ]; then
            root_latest=""
            if root_latest=$(go list -m -u -f '{{if .Update}}{{.Update.Version}}{{else}}{{.Version}}{{end}}' "$root" 2>/dev/null); then
                lgr WARN "failed to update ${mod}, retrying ${root}@${root_latest}"
                go get "${root}@${root_latest}" || return 1
            else
                lgr WARN "failed to resolve ${root}, retrying ${root}@latest"
                go get -u "${root}@latest" || return 1
            fi
        else
            return 1
        fi
    done

    if [ "$#" -gt 0 ]; then
        for mod in "$@"; do
            extra+=("${mod}@latest")
        done
        lgr I "updating extra modules: ${extra[*]}"
        go get -u "${extra[@]}" || return 1
    fi

    go mod tidy
}

##
## ########################################
##           Version Management
## ########################################

##
## -----
##
## version:upsert
##
## Save version to meta file.
## First time will create file if not present
##
## Arguments:
## @arg 1 {string} [tag=0.0.1]
function version:upsert {
    local tag=${1}

    if [ -z "$tag" ]; then
        version:get
    else
        version:set "$tag"
        version:get
    fi
}

##
## -----
##
## version:get
##
## Get version from meta file.
function version:get {

    test -f "${VERSION_FILE}" || touch "${VERSION_FILE}"

    local tag
    tag=$(cat "${VERSION_FILE}")

    if [ -z "$tag" ]; then
        tag="0.0.1"
        version:set "$tag"
    fi

    echo -n "$tag"
}

##
## -----
##
## version:set
##
## Set and save version to meta file.
## First time will create file if not present.
##
## Arguments:
## @arg 1 {string} [tag=0.0.1]
function version:set {

    local tag
    tag=${1}
    if [ -z "$tag" ]; then
        exit 1
    fi

    version:check

    echo -e "$tag" > "${VERSION_FILE}"
}

##
## -----
##
## version:bump
## Bump sem ver by specifying a level.
## Valid levels are:
## - patch (default)
## - minor
## - major
##
## If you want to update the .version file
## pass the `--write` flag.
## @see https://github.com/fsaintjacques/semver-tool/blob/master/src/semver
##
## @arg 1 {string} [level=patch]
## Outputs:
##   Semver string "$major.$minor.$patch"
##
## @flag --write Will write to .version file
##
function version:bump {

    version:check

    # Default values
    level='patch'
    write_to_file=0

    # Parse options
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --write)
                write_to_file=1
                shift
            ;;
            patch|minor|major)
                level=$1
                shift
            ;;
            *)
                echo "Invalid option: $1"
                return 2
            ;;
        esac
    done

    # Read contents of version and store in
    IFS='.' read -ra identifiers < "$VERSION_FILE"

    [[ "${#identifiers[@]}" -ne 3 ]] && echo "Invalid semver string" && return 1

    patch=${identifiers[2]}
    minor=${identifiers[1]}
    major=${identifiers[0]}

    case $level in
        patch)
            patch=$((patch+1))
        ;;
        minor)
            minor=$((minor+1))
            patch=0
        ;;
        major)
            major=$((major+1))
            minor=0
            patch=0
        ;;
        *)
            echo "Invalid level passed"
            return 2
    esac

    new_version="$major.$minor.$patch"

    if [[ $write_to_file -eq 1 ]]; then
        echo "$new_version" > "${VERSION_FILE}"
    else
        echo "$new_version"
    fi
}

function version:check {
    if [ ! -f "$VERSION_FILE" ]; then
        echo "0.0.0" > "$VERSION_FILE"
    fi
}

##
## -----
##
## quickstart:sync
##
## Keep quickstart module's go-admin requirement in sync
## with the release tag.
##
## Arguments:
## @arg 1 {string} tag
function quickstart:sync {
    local tag=${1}

    if [ -z "$tag" ]; then
        exit 1
    fi

    if [ ! -f "quickstart/go.mod" ]; then
        return 0
    fi

    (cd quickstart && go mod edit -require=github.com/goliatone/go-admin@v${tag})
    (cd quickstart && go mod tidy)
}


##
## -----
##
## release
##
## Bump our current version, create a git tag
## and push to trigger our release flow.
##
## Arguments:
## @arg 1 {string} [level=patch]
##        Accepted major, minor, patch
function release {
    local tag
    local level
    local message

    # Fetch all changes from origin
    git fetch --all
    # Make sure we have the latest version file
    git checkout origin/main -- ".version"

    # Pull tags to make sure we have
    git pull --tags -f

    level=${1:-"patch"}

    # Bump our version
    tag=$(version:bump "${level}")

    # Set message: default to New major|minor|patch release: vx.x.x
    message=${2:-"New ${level} release: v${tag}"}

    # Update version file
    version:set "${tag}"

    # Sync quickstart module to the new tag
    quickstart:sync "${tag}"

    # Add updated version file to git
    git add "${VERSION_FILE}"
    if [ -f "quickstart/go.mod" ]; then
        git add quickstart/go.mod quickstart/go.sum
    fi
    git commit -m "Bump version: v${tag}"

    # Create a new tag
    git tag -a "v${tag}" -m "${message}"
    git tag -a "quickstart/v${tag}" -m "Quickstart release: v${tag}"

    # Push tags and trigger release ðŸš€ ðŸ¥³
    git push --tags
    git push

    # Generate changelog
    git cliff --output CHANGELOG.md
    git add CHANGELOG.md
    git commit -m "docs: update changelog for v${tag}"

    git push
}

##########################################
# Help and auxiliary functions
##########################################

## Show function code
function help:show {
    declare -f "$1"
}

function help {
    echo ""
    echo "$0 <task> [...arguments]"
    echo ""
    echo "Project: ${PROJECT}"
    echo ""
    echo "Tasks:"
    compgen -A function | grep -v '^_' | cat -n
    echo ""

    prog="$0"
    me=$(basename "$prog")

    grep -e '^##[[:space:]]' -e '^##$' "$prog" | sed -e 's/^##//' -e "s/_PROG_/$me/" 2>&1 | less
}

TIMEFORMAT="Task completed in %3lR"
time "${@:-help}"
